#!/usr/bin/env python3

"""
Script to run limix to decompose variance in LMM models
Modified from https://github.com/johnlees/meningene/blob/master/bact_heritability/run_limix.py

Author: Stefano Giulieri
November 2021
"""

import sys
import argparse
import os
from glimix_core.lmm import LMM
import numpy as np
import pandas as pd
from numpy_sugar.linalg import economic_qs
import allel
from sklearn.decomposition import PCA

def get_genotype(geno_file):
    print("Parsing VCF file: {geno_file}")
    geno=allel.read_vcf(geno_file)
    gt=geno['calldata/GT']
    gt=allel.GenotypeArray(gt)
    G=gt.to_n_alt()

    return(G)
    
def run_pca(G,ncomp=None):
    pca = PCA()
    pca.fit(G)
    # print(pca.components_.shape)
    r=pca.components_[:,0:10]
    return(r)

# thanks to Francis Song for this function
# source: http://www.nervouscomputer.com/hfs/cmdscale-in-python/
def cmdscale(D):
    """Classical multidimensional scaling (MDS)
    Args:
        D (numpy.array)
            Symmetric distance matrix (n, n)
    Returns:
        Y (numpy.array)
            Configuration matrix (n, p). Each column represents a dimension. Only the
            p dimensions corresponding to positive eigenvalues of B are returned.
            Note that each dimension is only determined up to an overall sign,
            corresponding to a reflection.
        e (numpy.array)
            Eigenvalues of B (n, 1)
    """
    # Number of points
    n = len(D)

    # Centering matrix
    H = np.eye(n) - np.ones((n, n))/n

    # YY^T
    B = -H.dot(D**2).dot(H)/2

    # Diagonalize
    evals, evecs = np.linalg.eigh(B)

    # Sort by eigenvalue in descending order
    idx = np.argsort(evals)[::-1]
    evals = evals[idx]
    evecs = evecs[:, idx]

    # Compute the coordinates using positive-eigenvalued components only
    w, = np.where(evals > 0)
    L = np.diag(np.sqrt(evals[w]))
    V = evecs[:, w]
    Y = V.dot(L)

    return Y, evals[evals > 0]

def get_phenotype(pheno_file):
    pheno=[]
    samples=[]
    with open(pheno_file) as f:
        next(f)
        for line in f:
            i=line.split()[0]
            samples.append(i)
            p=line.split()[1]
            pheno.append(p)

    y = np.array(pheno)
    y=y.astype(np.float64)

    return(y, samples)

def get_kinship(distance_file, samples):
       K = pd.read_table(distance_file, index_col = 0)
       K = K.reindex(index=samples, columns=samples)
       K = K.values
       QS = economic_qs(K)

       return(QS)

def run_glmm(y, r, QS):
       glmm = LMM(y, r, QS)
       glmm.fit(verbose=True)

       fixed_effects_var=glmm.fixed_effects_variance
       print(fixed_effects_var)

       v0=glmm.v0
       print(v0)

       v1=glmm.v1
       print(v1)

       print("Part of the variance explained by the first 10 PC:")
       print(fixed_effects_var/(v0 + v1 + fixed_effects_var))

def main(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument('-g', '--geno_file', required = True,
                        help = 'Variants file in VCF format'
                        'generated by bcftools merge')
    parser.add_argument('-p', '--pheno_file', required = True,
                        help = 'Pyseer-style phenotype file')
    parser.add_argument('-d', '--distance_file', required = False,
                        help = 'Kinship matrix')
    parser.add_argument('-m', '--mash_file', required = False,
                        help = 'Mash distance file')
    args = parser.parse_args()
    geno_file = os.path.abspath(args.geno_file)
    pheno_file = os.path.abspath(args.pheno_file)
    distance_file = os.path.abspath(args.distance_file)
    mash_file = os.path.abspath(args.mash_file)

#    G=get_genotype(geno_file)
#    r=run_pca(G)
    D = pd.read_csv(mash_file,
                    index_col=0,
                    sep='\t')
    projection, evals = cmdscale(D)
    r = projection[:,:10]

    np.savetxt('mds.tab', r, delimiter = '\t')
    
    
    y, samples = get_phenotype(pheno_file)
    QS= get_kinship(distance_file, samples)
    run_glmm(y, r, QS)

    
if __name__ == "__main__":
    main(sys.argv[1:])
